package Project5;

import java.math.BigInteger;

public class RSA {

	public static void main(String[] args) 
	{
		//RSA encryption c = m^e %n
		//RSA decryption m = c^d %n
		
		//get ext Euclidan algorithmn up and running for calculating d and such.
		//Select p and q, which are 2 512 bit primes.
		BigInteger p = new BigInteger ("10420114435343421584900872011420348447007082906095422844459465548247386401885848518124279228981416500145014945974773331228264181981978897461511905365936923");
		BigInteger q = new BigInteger ("1247406511514577109853981639498844634596584766477349928071780564800311676683314247220052798676162460640686522815060909484623005051280404717674816311464841");
		// n = p*q, e = 65537
		BigInteger n = p.multiply(q);
		BigInteger e = new BigInteger ("65537");
		//phi(n) = (p-1)(q-1), which is relatively prime to 65537
		//calculate the secret exponent d s.t. e*d = 1 (mod phi(n))
		//verify that for numbers m times less than n, ((m^e %n)^d)%n == m
		double[] temp = extendedEuc(212, 24);
		double gcd = temp[0];
		
	}


	//This function will find what x^y is using the modular exponentiation algorithm.
	public static BigInteger modExpo(BigInteger x, BigInteger y, BigInteger N)
	{
		System.out.println(x + " " + y + " " + N);

		if (y == BigInteger.ZERO) return BigInteger.ONE;

		BigInteger z = modExpo(x, y.divide(new BigInteger("2")), N);


		if(y.mod(new BigInteger("2")) == BigInteger.ZERO)//Sees if the number is even of not.
		{
			//return ((long)Math.pow(z, 2)) % N;
			return z.pow(2).mod(N);
		}
		else
		{
			//return (x * ((long)Math.pow(z, 2))) % N;
			return x.multiply(z.pow(2)).mod(N);
		}
	}
	
	/*  
	 This function will perform the Extended Euclidean algorithm
     to find the GCD of a and b. We assume here that a and b
     are non-negative (and not both zero). This function also
     will return numbers j and k such that d = j*a + k*b, where d is the GCD of a and b.
     https://cgi.csc.liv.ac.uk/~martin/teaching/comp202/Java/GCD.html
	 */
    public static double[] extendedEuc(double a, double b)
    {
        double[] ans = new double[3];
        double q;

        if (b == 0)  {  /*  If b = 0, then we're done...  */
            ans[0] = a;
            ans[1] = 1;
            ans[2] = 0;
        }
        else
        {     
        	/*  Otherwise, make a recursive function call  */ 
            q = a/b;
            ans = extendedEuc (b, a % b);
            double temp = ans[1] - ans[2]*q;
            ans[1] = ans[2];
            ans[2] = Math.ceil(temp);//cause sometimes we get a wierd 
        }
        System.out.println("gcd = " + ans[0] + ", x = " + ans[1] + ", y = " + ans[2]);//gcd , x, y
        return ans;
    }
    
}

